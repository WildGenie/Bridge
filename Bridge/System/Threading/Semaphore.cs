// THIS FILE WAS AUTOMATICALLY GENERATED BY STUBBER

using System;
using System.Threading;
using System.Security.AccessControl;

namespace System.Threading {
    public class Semaphore: System.Threading.WaitHandle {

        public Semaphore( int initialCount, int maximumCount )  {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(Semaphore), typeof(Int32), typeof(Int32));
            }
        public Semaphore( int initialCount, int maximumCount, string name )  {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(Semaphore), typeof(Int32), typeof(Int32), typeof(String));
            }
        public Semaphore( int initialCount, int maximumCount, string name, System.Boolean createdNew )  {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(Semaphore), typeof(Int32), typeof(Int32), typeof(String), typeof(Boolean));
            }
        public Semaphore( int initialCount, int maximumCount, string name, System.Boolean createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity )  {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(Semaphore), typeof(Int32), typeof(Int32), typeof(String), typeof(Boolean), typeof(SemaphoreSecurity));
            }
        public static System.Threading.Semaphore OpenExisting( string name ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(OpenExisting), typeof(String) );
            return default( System.Threading.Semaphore );

		}
        public static System.Threading.Semaphore OpenExisting( string name, System.Security.AccessControl.SemaphoreRights rights ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(OpenExisting), typeof(String), typeof(SemaphoreRights) );
            return default( System.Threading.Semaphore );

		}
        public static bool TryOpenExisting( string name, out System.Threading.Semaphore result ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(TryOpenExisting), typeof(String), typeof(Semaphore) );
            result = default( System.Threading.Semaphore );

            return default( bool );

		}
        public static bool TryOpenExisting( string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(TryOpenExisting), typeof(String), typeof(SemaphoreRights), typeof(Semaphore) );
            result = default( System.Threading.Semaphore );

            return default( bool );

		}
        public int Release() {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(Release) );
            return default( int );

		}
        public int Release( int releaseCount ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(Release), typeof(Int32) );
            return default( int );

		}
        public System.Security.AccessControl.SemaphoreSecurity GetAccessControl() {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(GetAccessControl) );
            return default( System.Security.AccessControl.SemaphoreSecurity );

		}
        public void SetAccessControl( System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(SetAccessControl), typeof(SemaphoreSecurity) );
		}
        internal static System.IntPtr CreateSemaphore_internal( int initialCount, int maximumCount, string name, out System.Int32 errorCode ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(CreateSemaphore_internal), typeof(Int32), typeof(Int32), typeof(String), typeof(Int32) );
            errorCode = default( System.Int32 );

            return default( System.IntPtr );

		}
        internal static bool ReleaseSemaphore_internal( System.IntPtr handle, int releaseCount, out System.Int32 previousCount ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(ReleaseSemaphore_internal), typeof(IntPtr), typeof(Int32), typeof(Int32) );
            previousCount = default( System.Int32 );

            return default( bool );

		}
    }
}