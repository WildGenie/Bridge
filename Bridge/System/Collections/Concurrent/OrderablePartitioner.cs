// THIS FILE WAS AUTOMATICALLY GENERATED BY STUBBER

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Collections;

namespace System.Collections.Concurrent {
    public abstract class OrderablePartitioner<TSource> {

        public bool KeysOrderedInEachPartition {
			get{
				Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(KeysOrderedInEachPartition));
				return default (Boolean);
			}
		}
        public bool KeysOrderedAcrossPartitions {
			get{
				Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(KeysOrderedAcrossPartitions));
				return default (Boolean);
			}
		}
        public bool KeysNormalized {
			get{
				Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(KeysNormalized));
				return default (Boolean);
			}
		}
        public abstract System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>> GetOrderablePartitions( int partitionCount );

        public virtual System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions() {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(GetOrderableDynamicPartitions) );
            return default( System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> );

		}
        public System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<TSource>> GetPartitions( int partitionCount ) {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(GetPartitions), typeof(Int32) );
            return default( System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<TSource>> );

		}
        public System.Collections.Generic.IEnumerable<TSource> GetDynamicPartitions() {
			Bridge.Luna.Utils.Debug.WarnNotImplementedMethod(nameof(GetDynamicPartitions) );
            return default( System.Collections.Generic.IEnumerable<TSource> );

		}
    }
}